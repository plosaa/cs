## 向量的均摊复杂度
02.Vector.pdf P19

### 容量递增策略
每次需要扩容时容量增加常数 $I$

在初始容量为 $0$ 的空向量中，连续插入 $n = m * I >> 2$ 个元素：

在第 $1 , I + 1 , 2I + 1 , ... , (m - 1)I + 1$ 次插入时，都需扩容，

不算申请空间操作，复制的开销分别为 $0 , I , 2I , ... , (m - 1)I$ 。总耗时 $O(n^2)$ ，每次操作的分摊成本为 $O(n)$ 。

### 容量加倍策略
每次需要扩容时容量乘 $2$

在初始容量为 $1$ 的满向量中，连续插入 $n = 2^m >> 2$ 个元素：

在第 $1 , 2 , 4, ... , 2^{m - 1} + 1$ 次插入时，都需扩容，

复制的开销分别为 $0 , 1 , 2 , ... , 2^{m - 1}$ ，总开销 $O(2^m) = O(n)$，分摊复杂度为 $O(1)$ 。

或者这样来看：

插入 $n$ 次，扩容的次数为 $logn$ ，每次代价差不多是 $1 , 2 , 4 , ... $ ，这些相加相当于 $n$ 的比特位相加，所以最后的总开销是 $O(n)$ ，分摊下来是 $O(1)$ 。

## 缩容阈值
新威补充ppt：

![img](img/1.png)

缩容的阈值必须严格 $< 50\%$ ，不然可能反复扩容缩容，影响时间复杂度。

如果是 $50\%$ ，反复插入删除，扩容缩容的发生距离能为 $1$ 。

选 $49.9\%$ 都没问题，这样要连续删除 $0.1\% * n$ 次才会缩容。

## 有序向量唯一化
相关：[LeetCode26. 删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/)

```cpp
写法1：
int uniquify(vector<int> &nums) {
    int l = 1, r = 1; // l 为下一个独特元素该写入的位置
    while (r < nums.size()) {
        if (nums[r - 1] != nums[r]) { // 看 r - 1 与 r
            nums[l++] = nums[r];
        }
        r++;
    }
    return l; // 返回去重后的长度
}

写法2：
int uniquify(vector<int> &nums) {
    int l = 0, r = 1; // l 为最近发现的独特元素
    while (r < nums.size()) {
        if (nums[l] != nums[r]) { // 看 l 与 r
            nums[++l] = nums[r]; // j 是新发现的独特元素，写到 l + 1 位置
        }
        r++;
    }
    return l + 1; // 返回去重后的长度[0, l]
}
```